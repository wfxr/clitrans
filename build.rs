use indoc::*;
use serde::{Deserialize, Serialize};
use serde_json::value::RawValue;
use std::fs;
use std::io::Write;
use std::path::Path;
use std::str::FromStr;
use structopt::clap::Shell;

include!("src/cli.rs");

type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

fn main() -> Result<()> {
    gen_completions()?;
    gen_tests()?;
    Ok(())
}

fn gen_completions() -> Result<()> {
    let outdir = std::env::var_os("SHELL_COMPLETIONS_DIR")
        .or_else(|| std::env::var_os("OUT_DIR"))
        .expect("OUT_DIR not found");
    let outdir_path = Path::new(&outdir);
    let mut app = Opts::clap();

    for shell in &Shell::variants() {
        let dir = outdir_path.join(shell);
        fs::create_dir_all(&dir)?;
        app.gen_completions(env!("CARGO_PKG_NAME"), Shell::from_str(shell)?, &dir);
    }
    Ok(())
}

fn gen_tests() -> Result<()> {
    for key in &["bing", "youdao"] {
        let test_data = fs::read_to_string(format!("./tests/engine/{}/test_data.json", key))?;
        let test_data: Vec<TestData> = serde_json::from_str(&test_data)?;
        if !test_data.is_empty() {
            let mut file = fs::File::create(format!("./tests/engine/{}/mod.rs", key))?;
            writeln!(
                file,
                "{}",
                formatdoc! {r#"
                /// Generated by build.rs
                use clitrans::engine::{}::Translator;
                use clitrans::{{Translate, Translation}};
            "#, key},
            )?;
            for item in test_data.into_iter() {
                let test_fn = formatdoc! {r##"
                    #[test]
                    fn {}() {{
                        let trans = Translator;
                        let r = trans.translate("{}");
                        assert!(r.is_ok());
                        let r = r.unwrap();
                        assert!(r.is_some());
                        let r = r.unwrap();

                        let expected : Translation = serde_json::from_str(r#"
                            {}
                        "#)
                        .unwrap();
                        assert_eq!(r.query, expected.query, "{{}}", serde_json::to_string(&r).unwrap());
                        assert_eq!(r.url, expected.url, "{{}}", serde_json::to_string(&r).unwrap());
                        assert_eq!(r.exps, expected.exps);
                        assert_eq!(r.phrases, expected.phrases);
                    }}
                "##,
                    item.name,
                    item.input,
                    item.expect
                };
                writeln!(file, "{}", test_fn)?;
            }
            writeln!(file, "// vim: ro")?;
        }
    }
    Ok(())
}

#[derive(Serialize, Deserialize)]
struct TestData<'a> {
    name:   String,
    input:  String,
    #[serde(borrow)]
    expect: &'a RawValue,
}
